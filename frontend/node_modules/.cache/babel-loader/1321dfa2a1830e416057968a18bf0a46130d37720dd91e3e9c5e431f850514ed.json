{"ast":null,"code":"import { formatApiError as e, PrivyClientError as o, PrivyErrorCode as t } from \"../errors.mjs\";\nimport { recoveryOAuthInitICloudPath as r, recoveryOAuthInitPath as i, recoveryOAuthAuthenticatePath as E } from \"../paths.mjs\";\nimport { ModalScreen as a } from \"../screens/index.mjs\";\nimport { createCodeVerifier as n, createStateCode as s, deriveCodeChallengeFromCodeVerifier as c } from \"./pkce.mjs\";\nimport \"ofetch\";\nimport \"jose\";\nimport \"../constants.mjs\";\nimport \"../crypto.mjs\";\nimport \"../storage.mjs\";\nfunction d({\n  isCreatingWallet: e,\n  skipSplashScreen: o\n}) {\n  return e ? a.EMBEDDED_WALLET_PASSWORD_CREATE_SCREEN : o ? a.EMBEDDED_WALLET_PASSWORD_UPDATE_SCREEN : a.EMBEDDED_WALLET_PASSWORD_UPDATE_SPLASH_SCREEN;\n}\nfunction _({\n  walletAction: e,\n  availableRecoveryMethods: o,\n  legacySetWalletPasswordFlow: t,\n  isResettingPassword: r,\n  showAutomaticRecovery: i\n}) {\n  return i ? a.EMBEDDED_WALLET_SET_AUTOMATIC_RECOVERY_SCREEN : t || 1 === o.length ? d({\n    isCreatingWallet: \"create\" === e,\n    skipSplashScreen: r\n  }) : a.EMBEDDED_WALLET_RECOVERY_SELECTION_SCREEN;\n}\nfunction l(e) {\n  switch (e) {\n    case \"user-passcode\":\n      return a.EMBEDDED_WALLET_PASSWORD_RECOVERY_SCREEN;\n    case \"google-drive\":\n    case \"icloud\":\n      return a.EMBEDDED_WALLET_RECOVERY_OAUTH_SCREEN;\n    default:\n      throw Error(\"Recovery method not supported\");\n  }\n}\nasync function u({\n  api: o,\n  provider: t\n}) {\n  let E = n(),\n    a = s(),\n    d = await c(E);\n  try {\n    return \"icloud\" === t ? {\n      url: (await o.post(r, {\n        client_type: \"web\"\n      })).url\n    } : {\n      url: (await o.post(i, {\n        redirect_to: window.location.href,\n        code_challenge: d,\n        state_code: a\n      })).url,\n      codeVerifier: E,\n      stateCode: a,\n      provider: t\n    };\n  } catch (o) {\n    throw e(o);\n  }\n}\nasync function p({\n  api: r,\n  provider: i,\n  stateCode: a,\n  codeVerifier: n,\n  authorizationCode: s\n}) {\n  if (!s || !a) throw new o(\"[OAuth AuthFlow] Authorization and state codes code must be set prior to calling authenicate.\");\n  if (\"undefined\" === s) throw new o(\"User denied confirmation during OAuth flow\");\n  try {\n    return (await r.post(E, {\n      authorization_code: s,\n      state_code: a,\n      code_verifier: n,\n      provider: i\n    })).access_token;\n  } catch (r) {\n    let i = e(r);\n    if (i.privyErrorCode) throw new o(i.message || \"Invalid code during OAuth flow.\", void 0, i.privyErrorCode);\n    if (\"User denied confirmation during OAuth flow\" === i.message) throw new o(\"Invalid code during oauth flow.\", void 0, t.OAUTH_USER_DENIED);\n    throw new o(\"Invalid code during OAuth flow.\", void 0, t.UNKNOWN_AUTH_ERROR);\n  }\n}\nexport { p as authenticateRecovery, l as embeddedWalletRecoveryScreen, d as embeddedWalletSetPasswordScreen, u as getRecoveryAuthorizationUrl, _ as toEmbeddedWalletSetRecoveryScreen };","map":{"version":3,"names":["formatApiError","e","PrivyClientError","o","PrivyErrorCode","t","recoveryOAuthInitICloudPath","r","recoveryOAuthInitPath","i","recoveryOAuthAuthenticatePath","E","ModalScreen","a","createCodeVerifier","n","createStateCode","s","deriveCodeChallengeFromCodeVerifier","c","d","isCreatingWallet","skipSplashScreen","EMBEDDED_WALLET_PASSWORD_CREATE_SCREEN","EMBEDDED_WALLET_PASSWORD_UPDATE_SCREEN","EMBEDDED_WALLET_PASSWORD_UPDATE_SPLASH_SCREEN","_","walletAction","availableRecoveryMethods","legacySetWalletPasswordFlow","isResettingPassword","showAutomaticRecovery","EMBEDDED_WALLET_SET_AUTOMATIC_RECOVERY_SCREEN","length","EMBEDDED_WALLET_RECOVERY_SELECTION_SCREEN","l","EMBEDDED_WALLET_PASSWORD_RECOVERY_SCREEN","EMBEDDED_WALLET_RECOVERY_OAUTH_SCREEN","Error","u","api","provider","url","post","client_type","redirect_to","window","location","href","code_challenge","state_code","codeVerifier","stateCode","p","authorizationCode","authorization_code","code_verifier","access_token","privyErrorCode","message","OAUTH_USER_DENIED","UNKNOWN_AUTH_ERROR","authenticateRecovery","embeddedWalletRecoveryScreen","embeddedWalletSetPasswordScreen","getRecoveryAuthorizationUrl","toEmbeddedWalletSetRecoveryScreen"],"sources":["/Users/vickyfu/Documents/PredictX/frontend/node_modules/@privy-io/react-auth/dist/esm/lib/embeddedWalletRecovery.mjs"],"sourcesContent":["import{formatApiError as e,PrivyClientError as o,PrivyErrorCode as t}from\"../errors.mjs\";import{recoveryOAuthInitICloudPath as r,recoveryOAuthInitPath as i,recoveryOAuthAuthenticatePath as E}from\"../paths.mjs\";import{ModalScreen as a}from\"../screens/index.mjs\";import{createCodeVerifier as n,createStateCode as s,deriveCodeChallengeFromCodeVerifier as c}from\"./pkce.mjs\";import\"ofetch\";import\"jose\";import\"../constants.mjs\";import\"../crypto.mjs\";import\"../storage.mjs\";function d({isCreatingWallet:e,skipSplashScreen:o}){return e?a.EMBEDDED_WALLET_PASSWORD_CREATE_SCREEN:o?a.EMBEDDED_WALLET_PASSWORD_UPDATE_SCREEN:a.EMBEDDED_WALLET_PASSWORD_UPDATE_SPLASH_SCREEN}function _({walletAction:e,availableRecoveryMethods:o,legacySetWalletPasswordFlow:t,isResettingPassword:r,showAutomaticRecovery:i}){return i?a.EMBEDDED_WALLET_SET_AUTOMATIC_RECOVERY_SCREEN:t||1===o.length?d({isCreatingWallet:\"create\"===e,skipSplashScreen:r}):a.EMBEDDED_WALLET_RECOVERY_SELECTION_SCREEN}function l(e){switch(e){case\"user-passcode\":return a.EMBEDDED_WALLET_PASSWORD_RECOVERY_SCREEN;case\"google-drive\":case\"icloud\":return a.EMBEDDED_WALLET_RECOVERY_OAUTH_SCREEN;default:throw Error(\"Recovery method not supported\")}}async function u({api:o,provider:t}){let E=n(),a=s(),d=await c(E);try{return\"icloud\"===t?{url:(await o.post(r,{client_type:\"web\"})).url}:{url:(await o.post(i,{redirect_to:window.location.href,code_challenge:d,state_code:a})).url,codeVerifier:E,stateCode:a,provider:t}}catch(o){throw e(o)}}async function p({api:r,provider:i,stateCode:a,codeVerifier:n,authorizationCode:s}){if(!s||!a)throw new o(\"[OAuth AuthFlow] Authorization and state codes code must be set prior to calling authenicate.\");if(\"undefined\"===s)throw new o(\"User denied confirmation during OAuth flow\");try{return(await r.post(E,{authorization_code:s,state_code:a,code_verifier:n,provider:i})).access_token}catch(r){let i=e(r);if(i.privyErrorCode)throw new o(i.message||\"Invalid code during OAuth flow.\",void 0,i.privyErrorCode);if(\"User denied confirmation during OAuth flow\"===i.message)throw new o(\"Invalid code during oauth flow.\",void 0,t.OAUTH_USER_DENIED);throw new o(\"Invalid code during OAuth flow.\",void 0,t.UNKNOWN_AUTH_ERROR)}}export{p as authenticateRecovery,l as embeddedWalletRecoveryScreen,d as embeddedWalletSetPasswordScreen,u as getRecoveryAuthorizationUrl,_ as toEmbeddedWalletSetRecoveryScreen};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}