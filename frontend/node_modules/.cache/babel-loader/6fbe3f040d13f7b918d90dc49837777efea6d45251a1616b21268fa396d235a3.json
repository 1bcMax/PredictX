{"ast":null,"code":"import { getRandomBytes } from 'secure-password-utilities/csprng';\nconst MAXIMUM_ONE_BYTE_VALUE = 256;\nconst MAXIMUM_TWO_BYTE_VALUE = 65536;\nfunction getOneByteRandomInteger() {\n  const [byte] = getRandomBytes(1);\n  return byte;\n}\nfunction getTwoByteRandomInteger() {\n  const [byte1, byte2] = getRandomBytes(2);\n  return (byte1 << 8) + byte2;\n}\nfunction getRandomNumberLessThan(number) {\n  if (typeof number !== 'number' || number < 2 || number > MAXIMUM_TWO_BYTE_VALUE) {\n    throw new Error(`Invalid number: number must be at least two and at most ${MAXIMUM_TWO_BYTE_VALUE}`);\n  }\n  const needsTwoBytes = number > 256;\n  const maxValue = needsTwoBytes ? MAXIMUM_TWO_BYTE_VALUE : MAXIMUM_ONE_BYTE_VALUE;\n  const getRandomNumber = needsTwoBytes ? getTwoByteRandomInteger : getOneByteRandomInteger;\n  // We are going to calculate the maximum numeric value that is *evenly divisible* by\n  // the number argument. By only considering random values GTE zero and LT this value,\n  // we give each number in the requested range an equal probability of being chosen when\n  // using the modulo operator and thus avoiding modulo bias.\n  //\n  // The reason for choosing the maximum value, as opposed to the requested number argument\n  // itself, is efficiency. For example, let's say the number argument is 10. If we naively\n  // filter out any bytes from the RNG that are not between 0 and 10, then we would be\n  // rejecting > 95% of the bytes returned from the RNG. Instead we can do much better\n  // by selecting bytes in the range [0, 250) mod 10, which only rejects < 5% of bytes\n  // from the RNG. This is especially important when dealing with two-byte numbers.\n  const randomNumberMax = number * Math.floor(maxValue / number);\n  while (true) {\n    const randomNumber = getRandomNumber();\n    // Be careful that the random number is strictly LESS THAN the random number max.\n    if (randomNumber < randomNumberMax) {\n      return randomNumber % number;\n    }\n  }\n}\n/**\n * Get a list of random numbers where each number is greater than or equal to `start` and less than `end`.\n *\n * The `end` of the range must be less than or equal to 2^16.\n *\n * Examples:\n *\n *     getRandomNumbersInRange(6, 0, 10) // [8, 2, 1, 3, 5, 0]\n *\n *     getRandomNumbersInRange(6, 10, 1000); // [111, 752, 41, 420, 360, 630]\n *\n * @param length The length of the resulting list of random numbers.\n * @param start The start of the range (inclusive).\n * @param end The end of the range (exclusive). Cannot exceed 2^16.\n * @returns A list of `length` random numbers in the desired range.\n */\nexport function getRandomNumbersInRange(length, start, end) {\n  if (typeof length !== 'number' || length < 1) {\n    throw new Error('Invalid argument: length must be a number greater than or equal to 1');\n  }\n  if (typeof start !== 'number' || start < 0) {\n    throw new Error('Invalid argument: start must be a number greater than or equal to 0');\n  }\n  if (typeof end !== 'number' || end > MAXIMUM_TWO_BYTE_VALUE) {\n    throw new Error(`Invalid argument: end must be a number less than or equal to ${MAXIMUM_TWO_BYTE_VALUE}`);\n  }\n  if (end - start < 2) {\n    throw new Error('Invalid range: range must contain at least two values');\n  }\n  const values = [];\n  for (let i = 0; i < length; i++) {\n    values[i] = start + getRandomNumberLessThan(end - start);\n  }\n  return values;\n}\n/**\n * Randomize the ordering of the characters in the given string.\n *\n * Examples:\n *\n *     randomizeCharacters('randomize me');     // e znmaedimro\n *     randomizeCharacters('randomize me');     // arndimz moee\n *     randomizeCharacters('randomize me');     // ai emdonmrze\n *\n * @param characters A string of characters to randomize.\n * @returns A random ordering of the `characters` argument.\n */\nexport function randomizeCharacters(characters) {\n  if (typeof characters !== 'string') {\n    throw new Error('Invalid argument: characters argument must be a string');\n  }\n  const charactersLength = characters.length;\n  if (charactersLength < 2) {\n    return characters;\n  }\n  // Get random values within the index range of our input characters.\n  // We will use these values to swap elements from the input.\n  //\n  // NOTE: This can contain duplicates, which is desired (random), but it does\n  // mean that we cannot construct the resulting string solely from these values\n  // as they may contain duplicates and be missing some indices in the input string.\n  //\n  // For example:\n  //\n  //     * Let's say `characters` here is the string \"M9bz\"\n  //     * `charactersLength` is the number 4\n  //     * We'll then call getRandomValues(4, 4)\n  //     * This might return `UInt8Array([3, 2, 3, 0])`\n  //     * Then we'll iterate over the characters and at each position `i` we'll\n  //       swap `character[i]` with the one at `characters[swapIndices[i]]`.\n  //\n  const swapIndices = getRandomNumbersInRange(charactersLength, 0, charactersLength);\n  // We start with the input as a list because strings\n  // are immutable and we need to swap elements.\n  const result = Array.from(characters);\n  for (let i = 0; i < charactersLength; i++) {\n    const j = swapIndices[i];\n    // Swap elements at i and j\n    const temp = result[i];\n    result[i] = result[j];\n    result[j] = temp;\n  }\n  return result.join('');\n}\n/**\n * Get random values between 0 and `rangeMax` (at most, 256 exclusive) from a CSPRNG.\n *\n * This is a helper function to safely filter random byte values into a desired range.\n * \"safely\" here meaning careful use of the modulo operator to avoid modulo bias.\n *\n * This is deprecated. Use `getRandomNumbersInRange` instead.\n *\n * Examples:\n *\n *     getRandomValues(6, 10); // Returns a Uint8Array of length 6 with values between 0-9 inclusive.\n *\n *     getRandomValues(12, 52); // Returns a Uint8Array of length 12 with values between 0-51 inclusive.\n *\n * @deprecated\n * @param numValues The number of random values to return.\n * @param rangeMax Values returned must be strictly less than this value.\n * @returns A random set of values between 0 (inclusive) and rangeMax (exclusive).\n */\nexport function getRandomValues(numValues, rangeMax = 256) {\n  if (numValues < 0) {\n    throw new Error('Invalid number of values: number of values to return must be at least 0');\n  }\n  if (typeof rangeMax !== 'number' || rangeMax > 256) {\n    throw new Error('Invalid range max: range max must be a number that is at most 256');\n  }\n  if (numValues === 0) {\n    return new Uint8Array(0);\n  }\n  // Any byte values will work just fine in this case.\n  if (rangeMax === 256) {\n    return getRandomBytes(numValues);\n  }\n  const values = new Uint8Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    values[i] = getRandomNumberLessThan(rangeMax);\n  }\n  return values;\n}","map":{"version":3,"names":["getRandomBytes","MAXIMUM_ONE_BYTE_VALUE","MAXIMUM_TWO_BYTE_VALUE","getOneByteRandomInteger","byte","getTwoByteRandomInteger","byte1","byte2","getRandomNumberLessThan","number","Error","needsTwoBytes","maxValue","getRandomNumber","randomNumberMax","Math","floor","randomNumber","getRandomNumbersInRange","length","start","end","values","i","randomizeCharacters","characters","charactersLength","swapIndices","result","Array","from","j","temp","join","getRandomValues","numValues","rangeMax","Uint8Array"],"sources":["/Users/vickyfu/Documents/PredictX/frontend/node_modules/secure-password-utilities/src/random.ts"],"sourcesContent":["import { getRandomBytes } from 'secure-password-utilities/csprng';\n\nconst MAXIMUM_ONE_BYTE_VALUE = 256;\nconst MAXIMUM_TWO_BYTE_VALUE = 65536;\n\nfunction getOneByteRandomInteger() {\n  const [byte] = getRandomBytes(1);\n  return byte;\n}\n\nfunction getTwoByteRandomInteger() {\n  const [byte1, byte2] = getRandomBytes(2);\n  return (byte1 << 8) + byte2;\n}\n\nfunction getRandomNumberLessThan(number: number) {\n  if (typeof number !== 'number' || number < 2 || number > MAXIMUM_TWO_BYTE_VALUE) {\n    throw new Error(\n      `Invalid number: number must be at least two and at most ${MAXIMUM_TWO_BYTE_VALUE}`\n    );\n  }\n\n  const needsTwoBytes = number > 256;\n  const maxValue = needsTwoBytes ? MAXIMUM_TWO_BYTE_VALUE : MAXIMUM_ONE_BYTE_VALUE;\n  const getRandomNumber = needsTwoBytes ? getTwoByteRandomInteger : getOneByteRandomInteger;\n\n  // We are going to calculate the maximum numeric value that is *evenly divisible* by\n  // the number argument. By only considering random values GTE zero and LT this value,\n  // we give each number in the requested range an equal probability of being chosen when\n  // using the modulo operator and thus avoiding modulo bias.\n  //\n  // The reason for choosing the maximum value, as opposed to the requested number argument\n  // itself, is efficiency. For example, let's say the number argument is 10. If we naively\n  // filter out any bytes from the RNG that are not between 0 and 10, then we would be\n  // rejecting > 95% of the bytes returned from the RNG. Instead we can do much better\n  // by selecting bytes in the range [0, 250) mod 10, which only rejects < 5% of bytes\n  // from the RNG. This is especially important when dealing with two-byte numbers.\n  const randomNumberMax = number * Math.floor(maxValue / number);\n\n  while (true) {\n    const randomNumber = getRandomNumber();\n\n    // Be careful that the random number is strictly LESS THAN the random number max.\n    if (randomNumber < randomNumberMax) {\n      return randomNumber % number;\n    }\n  }\n}\n\n/**\n * Get a list of random numbers where each number is greater than or equal to `start` and less than `end`.\n *\n * The `end` of the range must be less than or equal to 2^16.\n *\n * Examples:\n *\n *     getRandomNumbersInRange(6, 0, 10) // [8, 2, 1, 3, 5, 0]\n *\n *     getRandomNumbersInRange(6, 10, 1000); // [111, 752, 41, 420, 360, 630]\n *\n * @param length The length of the resulting list of random numbers.\n * @param start The start of the range (inclusive).\n * @param end The end of the range (exclusive). Cannot exceed 2^16.\n * @returns A list of `length` random numbers in the desired range.\n */\nexport function getRandomNumbersInRange(length: number, start: number, end: number): number[] {\n  if (typeof length !== 'number' || length < 1) {\n    throw new Error('Invalid argument: length must be a number greater than or equal to 1');\n  }\n\n  if (typeof start !== 'number' || start < 0) {\n    throw new Error('Invalid argument: start must be a number greater than or equal to 0');\n  }\n\n  if (typeof end !== 'number' || end > MAXIMUM_TWO_BYTE_VALUE) {\n    throw new Error(\n      `Invalid argument: end must be a number less than or equal to ${MAXIMUM_TWO_BYTE_VALUE}`\n    );\n  }\n\n  if (end - start < 2) {\n    throw new Error('Invalid range: range must contain at least two values');\n  }\n\n  const values = [];\n\n  for (let i = 0; i < length; i++) {\n    values[i] = start + getRandomNumberLessThan(end - start);\n  }\n\n  return values;\n}\n\n/**\n * Randomize the ordering of the characters in the given string.\n *\n * Examples:\n *\n *     randomizeCharacters('randomize me');     // e znmaedimro\n *     randomizeCharacters('randomize me');     // arndimz moee\n *     randomizeCharacters('randomize me');     // ai emdonmrze\n *\n * @param characters A string of characters to randomize.\n * @returns A random ordering of the `characters` argument.\n */\nexport function randomizeCharacters(characters: string) {\n  if (typeof characters !== 'string') {\n    throw new Error('Invalid argument: characters argument must be a string');\n  }\n\n  const charactersLength = characters.length;\n\n  if (charactersLength < 2) {\n    return characters;\n  }\n\n  // Get random values within the index range of our input characters.\n  // We will use these values to swap elements from the input.\n  //\n  // NOTE: This can contain duplicates, which is desired (random), but it does\n  // mean that we cannot construct the resulting string solely from these values\n  // as they may contain duplicates and be missing some indices in the input string.\n  //\n  // For example:\n  //\n  //     * Let's say `characters` here is the string \"M9bz\"\n  //     * `charactersLength` is the number 4\n  //     * We'll then call getRandomValues(4, 4)\n  //     * This might return `UInt8Array([3, 2, 3, 0])`\n  //     * Then we'll iterate over the characters and at each position `i` we'll\n  //       swap `character[i]` with the one at `characters[swapIndices[i]]`.\n  //\n  const swapIndices = getRandomNumbersInRange(charactersLength, 0, charactersLength);\n\n  // We start with the input as a list because strings\n  // are immutable and we need to swap elements.\n  const result = Array.from(characters);\n\n  for (let i = 0; i < charactersLength; i++) {\n    const j = swapIndices[i];\n\n    // Swap elements at i and j\n    const temp = result[i];\n    result[i] = result[j];\n    result[j] = temp;\n  }\n\n  return result.join('');\n}\n\n/**\n * Get random values between 0 and `rangeMax` (at most, 256 exclusive) from a CSPRNG.\n *\n * This is a helper function to safely filter random byte values into a desired range.\n * \"safely\" here meaning careful use of the modulo operator to avoid modulo bias.\n *\n * This is deprecated. Use `getRandomNumbersInRange` instead.\n *\n * Examples:\n *\n *     getRandomValues(6, 10); // Returns a Uint8Array of length 6 with values between 0-9 inclusive.\n *\n *     getRandomValues(12, 52); // Returns a Uint8Array of length 12 with values between 0-51 inclusive.\n *\n * @deprecated\n * @param numValues The number of random values to return.\n * @param rangeMax Values returned must be strictly less than this value.\n * @returns A random set of values between 0 (inclusive) and rangeMax (exclusive).\n */\nexport function getRandomValues(numValues: number, rangeMax = 256): Uint8Array {\n  if (numValues < 0) {\n    throw new Error('Invalid number of values: number of values to return must be at least 0');\n  }\n\n  if (typeof rangeMax !== 'number' || rangeMax > 256) {\n    throw new Error('Invalid range max: range max must be a number that is at most 256');\n  }\n\n  if (numValues === 0) {\n    return new Uint8Array(0);\n  }\n\n  // Any byte values will work just fine in this case.\n  if (rangeMax === 256) {\n    return getRandomBytes(numValues);\n  }\n\n  const values = new Uint8Array(numValues);\n\n  for (let i = 0; i < numValues; i++) {\n    values[i] = getRandomNumberLessThan(rangeMax);\n  }\n\n  return values;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}